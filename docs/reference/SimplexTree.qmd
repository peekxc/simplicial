# SimplexTree

 --- 

## SimplexTree.SimplexTree { #SimplexTree.SimplexTree }

`SimplexTree.SimplexTree(self, simplices: Iterable[SimplexConvertible] = None)`

SimplexTree provides lightweight wrapper around a Simplex Tree data structure: an ordered, trie-like structure whose nodes are in bijection with the faces of the complex. 
This class exposes a native extension module wrapping a simplex tree implemented with modern C++.

The Simplex Tree was originally introduced in the paper
> Boissonnat, Jean-Daniel, and Cl√©ment Maria. "The simplex tree: An efficient data structure for general simplicial complexes." Algorithmica 70.3 (2014): 406-427.

### Attributes

| Name        | Type    | Description                          |
|-------------|---------|--------------------------------------|
| n_simplices | ndarray | number of simplices                  |
| dimension   | int     | maximal dimension of the complex     |
| id_policy   | str     | policy for generating new vertex ids |

### Attributes

| Name     | Type    | Description             |
|----------|---------|-------------------------|
| vertices | ndarray | vertices of the complex |

 --- 

## SimplexTree.insert { #SimplexTree.insert }

`SimplexTree.insert(self, simplices: Iterable[SimplexConvertible])`

Inserts simplices into the Simplex Tree. 

By definition, inserting a simplex also inserts all of its faces. If the simplex already exists in the complex, the tree is not modified. 

### Parameters

**simplices** : <span class='type_annotation'> Iterable[SimplexConvertible], </span>required<p> Iterable of simplices to insert (each of which are SimplexLike) </p>

::: {.callout-note}
        If the iterable is an 2-dim np.ndarray, then a p-simplex is inserted along each contiguous p+1 stride.
        Otherwise, each element of the iterable to casted to a Simplex and then inserted into the tree. 
:::

 --- 

## SimplexTree.remove { #SimplexTree.remove }

`SimplexTree.remove(self, simplices: Iterable[SimplexLike])`

Removes simplices into the Simplex Tree. 

By definition, removing a face also removes all of its cofaces. If the simplex does not exist in the complex, the tree is not modified. 

### Parameters

**simplices** : <span class='type_annotation'> Iterable[SimplexLike], </span>required<p> 
Iterable of simplices to insert (each of which are SimplexLike).                 </p>

::: {.callout-note}
        If the iterable is an 2-dim np.ndarray, then a p-simplex is removed along each contiguous p+1 stride.
        Otherwise, each element of the iterable to casted to a Simplex and then removed from the tree. 
:::

 --- 

## SimplexTree.find { #SimplexTree.find }

`SimplexTree.find(self, simplices: Iterable[SimplexLike])`

Finds whether simplices exist in Simplex Tree. 

### Parameters

**simplices** : <span class='type_annotation'> Iterable[SimplexLike], </span>required<p> Iterable of simplices to insert (each of which are SimplexLike) </p>

### Returns

**** : <p> found (ndarray) : boolean array for each simplex indicating whether it was found in the complex </p>

::: {.callout-note}
        If the iterable is an 2-dim np.ndarray, then the p-simplex to find is given by each contiguous p+1 stride.
        Otherwise, each element of the iterable to casted to a Simplex and then searched for in the tree. 
:::

 --- 

## SimplexTree.adjacent { #SimplexTree.adjacent }

`SimplexTree.adjacent(self, simplices: Iterable)`

Checks for adjacencies between simplices

 --- 

## SimplexTree.collapse { #SimplexTree.collapse }

`SimplexTree.collapse(self, tau: SimplexConvertible, sigma: SimplexConvertible)`

Checks whether its possible to collapse $\sigma$ through $\tau$, and if so, both simplices are removed. 
A simplex $\sigma$ is said to be collapsible through one of its faces $\tau$ if $\sigma$ is the only coface of $\tau$ (excluding $\tau$ itself). 

### Parameters

**sigma** : required<p> maximal simplex to collapse </p>

**tau** : required<p> face of sigma to collapse  </p>

### Returns

**bool** : None, <p> whether the pair was collapsed </p>

### Examples

```{python}
from splex import SimplexTree 
st = SimplexTree([[0,1,2]])
print(st)

st.collapse([1,2], [0,1,2])

print(st)
```

 --- 

## SimplexTree.vertex_collapse { #SimplexTree.vertex_collapse }

`SimplexTree.vertex_collapse(self, u: int, v: int, w: int)`

Maps a pair of vertices into a single vertex. 

### Parameters

**u** : <span class='type_annotation'> int, </span>required<p> the first vertex in the free pair. </p>

**v** : <span class='type_annotation'> int, </span>required<p> the second vertex in the free pair.  </p>

**w** : <span class='type_annotation'> int, </span>required<p> the target vertex to collapse to. </p>

 --- 

## SimplexTree.degree { #SimplexTree.degree }

`SimplexTree.degree(self, vertices: Optional[ArrayLike] = None)`

Computes the degree of select vertices in the trie.

### Parameters

**vertices** : <span class='type_annotation'> numpy.typing.ArrayLike, </span>optional (default=None)<p> Retrieves vertex degrees
If no vertices are specified, all degrees are computed. Non-existing vertices by default have degree 0.  </p>

### Returns

**list** : <span class='type_annotation'> Union[ArrayLike, int], </span><p> degree of each vertex id given in 'vertices' </p>

 --- 

## SimplexTree.traverse { #SimplexTree.traverse }

`SimplexTree.traverse(self, order: str = 'preorder', f: Callable = print, sigma: SimplexLike = [], p: int = 0)`

Traverses the simplex tree in the specified order, calling 'f' on each simplex encountered

Supported traversals: 
        - breadth-first / level order ("bfs", "levelorder") 
        - depth-first / prefix ("dfs", "preorder")
        - faces ("faces")
        - cofaces ("cofaces")
        - coface roots 
        - p-skeleton
        - p-simplices 
        - maximal simplices 
        - link 
To select one of these options, set order to one of ["bfs", "levelorder", "dfs", "preorder"]

### Parameters

**order** : optional (default='preorder')<p> the type of traversal to do  </p>

**f** : optional (default=print)<p> a function to evaluate on every simplex in the traversal. Defaults to print.  </p>

**sigma** : optional (default=[])<p> simplex to start the traversal at, where applicable. Defaults to the root node (empty set) </p>

**p** : optional (default=0)<p> dimension of simplices to restrict to, where applicable. </p>

 --- 

## SimplexTree.cofaces { #SimplexTree.cofaces }

`SimplexTree.cofaces(self, p: int = None, sigma: SimplexLike = [])`

Finds the p-dimensional cofaces of sigma.

### Parameters

**p** : optional (default=None)<p> coface dimension to restrict to  </p>

**sigma** : optional (default=[])<p> the simplex to obtain cofaces of </p>

### Returns

**list** : <span class='type_annotation'> list[SimplexLike], </span><p> the p-cofaces of sigma </p>

 --- 

## SimplexTree.coface_roots { #SimplexTree.coface_roots }

`SimplexTree.coface_roots(self, p: int = None, sigma: SimplexLike = [])`

 --- 

## SimplexTree.skeleton { #SimplexTree.skeleton }

`SimplexTree.skeleton(self, p: int = None)`

 --- 

## SimplexTree.simplices { #SimplexTree.simplices }

`SimplexTree.simplices(self, p: int = None, sigma: SimplexLike = [])`

 --- 

## SimplexTree.maximal { #SimplexTree.maximal }

`SimplexTree.maximal(self)`

 --- 

## SimplexTree.link { #SimplexTree.link }

`SimplexTree.link(self, sigma: SimplexLike = [])`

 --- 

## SimplexTree.expand { #SimplexTree.expand }

`SimplexTree.expand(self, k: int)`

Performs a k-expansion of the complex.

This function is particularly useful for expanding clique complexes beyond their 1-skeleton. 

### Parameters

**k** : required<p> maximum dimension to expand to.  </p>

### Examples

```{python}
from splex import SimplexTree 
from itertools import combinations 
st = SimplexTree(combinations(range(8), 2))
print(st)

st.expand(k=2)
print(st)
```

 --- 

## SimplexTree.card { #SimplexTree.card }

`SimplexTree.card(self, p: int = None)`

 --- 

## _simplextree.SimplexTree { #_simplextree.SimplexTree }

`_simplextree.SimplexTree()`

 --- 

## SimplexTree.clear { #SimplexTree.clear }

`SimplexTree.clear()`

clear(self: splex.complexes._simplextree.SimplexTree) -> None

 --- 

## SimplexTree.generate_ids { #SimplexTree.generate_ids }

`SimplexTree.generate_ids()`

generate_ids(self: splex.complexes._simplextree.SimplexTree, arg0: int) -> List[int]

 --- 

## SimplexTree.is_tree { #SimplexTree.is_tree }

`SimplexTree.is_tree()`

is_tree(self: splex.complexes._simplextree.SimplexTree) -> bool

 --- 

## SimplexTree.print_cousins { #SimplexTree.print_cousins }

`SimplexTree.print_cousins()`

print_cousins(self: splex.complexes._simplextree.SimplexTree) -> None

 --- 

## SimplexTree.print_tree { #SimplexTree.print_tree }

`SimplexTree.print_tree()`

print_tree(self: splex.complexes._simplextree.SimplexTree) -> None