[
  {
    "objectID": "pages/overview.html",
    "href": "pages/overview.html",
    "title": "Overview: Simplicial Complexes",
    "section": "",
    "text": "A simplicial complex S = (V, \\Sigma) is a collection of simplices s \\in \\Sigma satisfying:\n\nEach v \\in V is in S\nIf \\tau \\subset \\sigma and \\sigma \\in S, then \\tau \\in S\n\nMathematically, one can think of a simplicial complex as a natural generalization of a graph: indeed, the 1-skeleton of S is a graph, and thus any graph can also be represented by a simplicial complex (though the converse is not true!).\nAs an abstract data type, graph data structures are highly varied—common choices include incidence matrices, adjacency matrices, edge lists, adjacency lists, pointer-based representations, or even dictionary representations. It is often the case that choosing the ‘right’ data structure for a computational task depends on the intended use-case: (TODO: show usages). To make matters more complicated, this use-case often changes throughout the development cycle of a software project—for example, dictionary-based graph representations might be great for interactive construction and manipulation, but when it faced with a compute-heavy task (e.g. any linear algebra task), one must often switch to a matrix-representations before proceeding.\n\n\nsplex promotes a common, pythonic interface for interacting with simplicial complexes that is independent of their internal representation.\nTo simplify usage, this interface incorporates the use of generics (inspired from R) and Protocol classes (to support duck-typing and structural subtyping).\nSee the design philosophy (todo) for more details.\n\n\n\nOut-of-the-box, splex comes with three distinct data structures for representing simplicial complexes: as sets of simplices, as (structured) arrays of integers, and as integer-valued tries. See the complexes overview page for more details."
  },
  {
    "objectID": "pages/simplextree_ds.html",
    "href": "pages/simplextree_ds.html",
    "title": "Simplex Tree",
    "section": "",
    "text": "Simplex Tree\nThe simplex tree is…\n\n\n\nsimplextree"
  },
  {
    "objectID": "reference/generics.boundary.html",
    "href": "reference/generics.boundary.html",
    "title": "generics.boundary",
    "section": "",
    "text": "generics.boundary\ngenerics.boundary(s, p=None, oriented=False, **kwargs)\nReturns the boundary of a simplicial object, optionally signed.\nIf s has an existing method s.boundary(p, oriented), then that method is called with additional keyword args kwargs.\nOtherwise, the behavior of this function depends on the type-class of s. Namely, - if s is SimplexLike with dimension p, then a generator enumerating (p-1)-faces of s is created. - if s is ComplexLike, then a sparse boundary matrix whose columns represent boundary chains is returned. - if s is FiltrationLike, then a sparse boundary matrix whose columns represent boundary chains in filtration order is returned. - if s is none of the above but is Sized and Iterable, all len(s)-1 combinations are returned of s are returned.\nTODO: finish this"
  },
  {
    "objectID": "reference/meta.html",
    "href": "reference/meta.html",
    "title": "meta",
    "section": "",
    "text": "meta\n\n\n\n\n\nName\nDescription\n\n\n\n\nIT\n\n\n\nPropertySimplexConvertible"
  },
  {
    "objectID": "reference/generics.dim.html",
    "href": "reference/generics.dim.html",
    "title": "generics.dim",
    "section": "",
    "text": "generics.dim\ngenerics.dim(s, **kwargs)\nReturns the dimension of a simplicial object.\nIf s has an existing method s.dim(…), then that method is called with additional keyword arguments kwargs.\nOtherwise, the behavior of this function depends on the type-class of s. Namely, - if s is SimplexLike with dimension p, then p is returned. - if s is ComplexLike, then the largest dimension p of any face in s is returned. - if s is none of the above but is Sized, len(s) - 1 is returned."
  },
  {
    "objectID": "reference/complexes.SetComplex.SetComplex.html",
    "href": "reference/complexes.SetComplex.SetComplex.html",
    "title": "complexes.SetComplex.SetComplex",
    "section": "",
    "text": "complexes.SetComplex.SetComplex(self, simplices=None)\nAbstract Simplicial Complex\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd\n\n\n\ncard\n\n\n\ncofaces\n\n\n\ndim\n\n\n\ndiscard\n\n\n\nfaces\n\n\n\nremove\n\n\n\nupdate\n\n\n\n\n\n\ncomplexes.SetComplex.SetComplex.add(self, item)\n\n\n\ncomplexes.SetComplex.SetComplex.card(self, p=None)\n\n\n\ncomplexes.SetComplex.SetComplex.cofaces(self, item)\n\n\n\ncomplexes.SetComplex.SetComplex.dim(self)\n\n\n\ncomplexes.SetComplex.SetComplex.discard(self, item)\n\n\n\ncomplexes.SetComplex.SetComplex.faces(self, p=None, **kwargs)\n\n\n\ncomplexes.SetComplex.SetComplex.remove(self, item)\n\n\n\ncomplexes.SetComplex.SetComplex.update(self, simplices)"
  },
  {
    "objectID": "reference/sparse.html",
    "href": "reference/sparse.html",
    "title": "sparse",
    "section": "",
    "text": "sparse\n\n\n\n\n\nName\nDescription\n\n\n\n\nboundary_matrix\nConstructs a sparse boundary matrix of a given simplicial object K\n\n\n\n\n\nsparse.boundary_matrix(K, p=None)\nConstructs a sparse boundary matrix of a given simplicial object K\nParameters: K: simplicial complex (optionally filtered) or ComplexLike. p: dimension of the p-chains to form the columns.\nReturns: D: sparse matrix representing either the full or p-th boundary matrix (as List-of-Lists format)"
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "API Reference",
    "section": "",
    "text": "Data structures for constructing and modifying abstract simplicial complexes\n\n\n\ncomplexes.SetComplex.SetComplex\nAbstract Simplicial Complex\n\n\ncomplexes.RankComplex.RankComplex\nSimplicial complex represented via the combinatorial number system.\n\n\ncomplexes.SimplexTree.SimplexTree\nSimplexTree provides lightweight wrapper around a Simplex Tree data structure: an ordered, trie-like structure whose nodes are in bijection with the faces of the complex.\n\n\n\n\n\n\nData structures for constructing and modifying filtered simplicial complexes\n\n\n\nfiltrations.SetFiltration.SetFiltration\nFiltered complex of simplices uses SortedSet.\n\n\n\n\n\n\nGeneric functions that work with any simplicial representation that supports the Protocol interface.\n\n\n\ngenerics\n\n\n\n\n\n\n\nProtocol classes that define loose interfaces for duck typing and structural subtyping support.\n\n\n\nmeta\n\n\n\n\n\n\n\nProtocol classes that define loose interfaces for duck typing and structural subtyping support.\n\n\n\nmeta\n\n\n\n\n\n\n\nFunctions for constructing simplicial complexes and filtrations from geometric settings.\n\n\n\ngeometry\n\n\n\n\n\n\n\nFunctions useful for performing linear algebraic operations on simplicial complexes.\n\n\n\nsparse"
  },
  {
    "objectID": "reference/generics.html",
    "href": "reference/generics.html",
    "title": "generics",
    "section": "",
    "text": "generics\n\n\n\n\n\nName\nDescription\n\n\n\n\nboundary\nReturns the boundary of a simplicial object, optionally signed.\n\n\ncard\nCounts the number of p-dimensional simplices of a simplicial object s.\n\n\ndim\nReturns the dimension of a simplicial object.\n\n\nfaces\nReturns the faces of a simplicial object, optionally restricted by dimension.\n\n\nhandle_data\n\n\n\n\n\n\n\ngenerics.boundary(s, p=None, oriented=False, **kwargs)\nReturns the boundary of a simplicial object, optionally signed.\nIf s has an existing method s.boundary(p, oriented), then that method is called with additional keyword args kwargs.\nOtherwise, the behavior of this function depends on the type-class of s. Namely, - if s is SimplexLike with dimension p, then a generator enumerating (p-1)-faces of s is created. - if s is ComplexLike, then a sparse boundary matrix whose columns represent boundary chains is returned. - if s is FiltrationLike, then a sparse boundary matrix whose columns represent boundary chains in filtration order is returned. - if s is none of the above but is Sized and Iterable, all len(s)-1 combinations are returned of s are returned.\nTODO: finish this\n\n\n\ngenerics.card(s, p=None, **kwargs)\nCounts the number of p-dimensional simplices of a simplicial object s.\nIf s has an existing method s.card(p), then that method is called with additional keyword arguments kwargs.\nOtherwise, the behavior of this function depends on the type-class of s and whether p is specified. Namely, - If s is complex like, then card(s) returns a tuple containing the number of simplices in s in each dimension, and card(s, p) the number of simplices in s with dimension p.\n\n\n\ngenerics.dim(s, **kwargs)\nReturns the dimension of a simplicial object.\nIf s has an existing method s.dim(…), then that method is called with additional keyword arguments kwargs.\nOtherwise, the behavior of this function depends on the type-class of s. Namely, - if s is SimplexLike with dimension p, then p is returned. - if s is ComplexLike, then the largest dimension p of any face in s is returned. - if s is none of the above but is Sized, len(s) - 1 is returned.\n\n\n\ngenerics.faces(s, p=None, data=False, **kwargs)\nReturns the faces of a simplicial object, optionally restricted by dimension.\nIf s has an existing method s.faces(p), then that method is called with additional keyword arguments kwargs.\nOtherwise, the behavior of this function depends on the type-class of s. Namely, - if s is SimplexLike, then a generator enumerating p-combinations of s is returned. - if s is ComplexLike, then a generator enumerating p-faces of s (in any order) is returned. - if s is FiltrationLike, then a generator enumerating p-faces of s in filtration order is returned. - if s is none of the above but is Sized and Iterable, all combinations of s of length p+1 are chained and returned.\n\n\n\ngenerics.handle_data(g, data)"
  },
  {
    "objectID": "reference/complexes.SimplexTree.SimplexTree.html",
    "href": "reference/complexes.SimplexTree.SimplexTree.html",
    "title": "complexes.SimplexTree.SimplexTree",
    "section": "",
    "text": "complexes.SimplexTree.SimplexTree(self, simplices=None)\nSimplexTree provides lightweight wrapper around a Simplex Tree data structure: an ordered, trie-like structure whose nodes are in bijection with the faces of the complex. This class exposes a native extension module wrapping a simplex tree implemented with modern C++.\nThe Simplex Tree was originally introduced in the paper &gt; Boissonnat, Jean-Daniel, and Clément Maria. “The simplex tree: An efficient data structure for general simplicial complexes.” Algorithmica 70.3 (2014): 406-427.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nn_simplices\nndarray\nnumber of simplices\n\n\ndimension\nint\nmaximal dimension of the complex\n\n\nid_policy\nstr\npolicy for generating new vertex ids\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nvertices\nndarray\nvertices of the complex\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nadjacent\nChecks for adjacencies between simplices\n\n\ncard\n\n\n\ncoface_roots\n\n\n\ncofaces\nFinds the p-dimensional cofaces of sigma.\n\n\ncollapse\nChecks whether its possible to collapse \\sigma through \\tau, and if so, both simplices are removed.\n\n\ndegree\nComputes the degree of select vertices in the trie.\n\n\nexpand\nPerforms a k-expansion of the complex.\n\n\nfind\nFinds whether simplices exist in Simplex Tree.\n\n\ninsert\nInserts simplices into the Simplex Tree.\n\n\nlink\n\n\n\nmaximal\nMaximal simplices.\n\n\nremove\nRemoves simplices into the Simplex Tree.\n\n\nsimplices\n\n\n\nskeleton\n\n\n\ntraverse\nTraverses the simplex tree in the specified order, calling ‘f’ on each simplex encountered\n\n\nvertex_collapse\nMaps a pair of vertices into a single vertex.\n\n\n\n\n\ncomplexes.SimplexTree.SimplexTree.adjacent(self, simplices)\nChecks for adjacencies between simplices\n\n\n\ncomplexes.SimplexTree.SimplexTree.card(self, p=None)\n\n\n\ncomplexes.SimplexTree.SimplexTree.coface_roots(self, sigma=\\[\\])\n\n\n\ncomplexes.SimplexTree.SimplexTree.cofaces(self, sigma=\\[\\])\nFinds the p-dimensional cofaces of sigma.\n\n\np : required\n\ncoface dimension to restrict to\n\nsigma : optional (default=[])\n\nthe simplex to obtain cofaces of\n\n\n\n\nlist :  list[SimplexLike], \n\nthe p-cofaces of sigma\n\n\n\n\n\ncomplexes.SimplexTree.SimplexTree.collapse(self, tau, sigma)\nChecks whether its possible to collapse \\sigma through \\tau, and if so, both simplices are removed. A simplex \\sigma is said to be collapsible through one of its faces \\tau if \\sigma is the only coface of \\tau (excluding \\tau itself).\n\n\nsigma : required\n\nmaximal simplex to collapse\n\ntau : required\n\nface of sigma to collapse\n\n\n\n\nbool : None,\n\nwhether the pair was collapsed\n\n\n\n\nfrom splex import SimplexTree st = SimplexTree([[0,1,2]]) print(st)\nst.collapse([1,2], [0,1,2])\nprint(st)\n\n\n\n\ncomplexes.SimplexTree.SimplexTree.degree(self, vertices=None)\nComputes the degree of select vertices in the trie.\n\n\nvertices :  numpy.typing.ArrayLike, optional (default=None)\n\nRetrieves vertex degrees If no vertices are specified, all degrees are computed. Non-existing vertices by default have degree 0.\n\n\n\n\nlist :  Union[ArrayLike, int], \n\ndegree of each vertex id given in ‘vertices’\n\n\n\n\n\ncomplexes.SimplexTree.SimplexTree.expand(self, k)\nPerforms a k-expansion of the complex.\nThis function is particularly useful for expanding clique complexes beyond their 1-skeleton.\n\n\nk : required\n\nmaximum dimension to expand to.\n\n\n\n\nfrom splex import SimplexTree from itertools import combinations st = SimplexTree(combinations(range(8), 2)) print(st)\nst.expand(k=2) print(st)\n\n\n\n\ncomplexes.SimplexTree.SimplexTree.find(self, simplices)\nFinds whether simplices exist in Simplex Tree.\n\n\nsimplices :  Iterable[SimplexLike], required\n\nIterable of simplices to insert (each of which are SimplexLike)\n\n\n\n\n**** :\n\nfound (ndarray) : boolean array for each simplex indicating whether it was found in the complex\n\n\n\n\n\n\n\nNote\n\n\n\n    If the iterable is an 2-dim np.ndarray, then the p-simplex to find is given by each contiguous p+1 stride.\n    Otherwise, each element of the iterable to casted to a Simplex and then searched for in the tree. \n\n\n\n\n\n\ncomplexes.SimplexTree.SimplexTree.insert(self, simplices)\nInserts simplices into the Simplex Tree.\nBy definition, inserting a simplex also inserts all of its faces. If the simplex already exists in the complex, the tree is not modified.\n\n\nsimplices :  Iterable[SimplexConvertible], required\n\nIterable of simplices to insert (each of which are SimplexLike)\n\n\n\n\n\n\n\nNote\n\n\n\n    If the iterable is an 2-dim np.ndarray, then a p-simplex is inserted along each contiguous p+1 stride.\n    Otherwise, each element of the iterable to casted to a Simplex and then inserted into the tree. \n\n\n\n\n\n\ncomplexes.SimplexTree.SimplexTree.link(self, sigma=\\[\\])\n\n\n\ncomplexes.SimplexTree.SimplexTree.maximal(self)\nMaximal simplices.\n\n\n\ncomplexes.SimplexTree.SimplexTree.remove(self, simplices)\nRemoves simplices into the Simplex Tree.\nBy definition, removing a face also removes all of its cofaces. If the simplex does not exist in the complex, the tree is not modified.\n\n\nsimplices :  Iterable[SimplexLike], required\n\nIterable of simplices to insert (each of which are SimplexLike).\n\n\n\n\n\n\n\nNote\n\n\n\n    If the iterable is an 2-dim np.ndarray, then a p-simplex is removed along each contiguous p+1 stride.\n    Otherwise, each element of the iterable to casted to a Simplex and then removed from the tree. \n\n\n\n\n\nst = SimplexTree([range(3)]) print(st) st.remove([[0,1]]) print(st)\n\n\n\n\ncomplexes.SimplexTree.SimplexTree.simplices(self, p=None, sigma=\\[\\])\n\n\n\ncomplexes.SimplexTree.SimplexTree.skeleton(self, p=None, sigma=\\[\\])\n\n\n\ncomplexes.SimplexTree.SimplexTree.traverse(self, order='preorder', f=print, sigma=\\[\\], p=0)\nTraverses the simplex tree in the specified order, calling ‘f’ on each simplex encountered\nSupported traversals: - breadth-first / level order (“bfs”, “levelorder”) - depth-first / prefix (“dfs”, “preorder”) - faces (“faces”) - cofaces (“cofaces”) - coface roots - p-skeleton - p-simplices - maximal simplices - link To select one of these options, set order to one of [“bfs”, “levelorder”, “dfs”, “preorder”]\n\n\norder : optional (default=‘preorder’)\n\nthe type of traversal to do\n\nf : optional (default=print)\n\na function to evaluate on every simplex in the traversal. Defaults to print.\n\nsigma : optional (default=[])\n\nsimplex to start the traversal at, where applicable. Defaults to the root node (empty set)\n\np : optional (default=0)\n\ndimension of simplices to restrict to, where applicable.\n\n\n\n\n\ncomplexes.SimplexTree.SimplexTree.vertex_collapse(self, u, v, w)\nMaps a pair of vertices into a single vertex.\n\n\nu :  int, required\n\nthe first vertex in the free pair.\n\nv :  int, required\n\nthe second vertex in the free pair.\n\nw :  int, required\n\nthe target vertex to collapse to."
  },
  {
    "objectID": "reference/geometry.html",
    "href": "reference/geometry.html",
    "title": "geometry",
    "section": "",
    "text": "geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\nas_pairwise_dist\n\n\n\ndelaunay_complex\n\n\n\nenclosing_radius\nReturns the smallest ‘r’ such that the Rips complex on the union of balls of radius ‘r’ is contractible to a point.\n\n\nflag_weight\n\n\n\nlower_star_weight\nConstructs a simplex-parameterized Callable that evaluates its lower star value based on x.\n\n\nrips_complex\n\n\n\nrips_filtration\n\n\n\n\n\n\ngeometry.as_pairwise_dist(x)\n\n\n\ngeometry.delaunay_complex(x)\n\n\n\ngeometry.enclosing_radius(x)\nReturns the smallest ‘r’ such that the Rips complex on the union of balls of radius ‘r’ is contractible to a point.\n\n\n\ngeometry.flag_weight(x, vertex_weights=None)\n\n\n\ngeometry.lower_star_weight(x)\nConstructs a simplex-parameterized Callable that evaluates its lower star value based on x.\nVertex labels are assumed to be 0-indexed for now.\nIf simplex-like, use 0-indexed vertex labels to index vertex values directly.\nOtherwise assumes a 2d array of simplex labels is given and vectorizes the computation.\n\n\n\ngeometry.rips_complex(x, radius=None, p=1)\n\n\n\ngeometry.rips_filtration(x, radius=None, p=1, **kwargs)"
  },
  {
    "objectID": "reference/generics.faces.html",
    "href": "reference/generics.faces.html",
    "title": "generics.faces",
    "section": "",
    "text": "generics.faces\ngenerics.faces(s, p=None, data=False, **kwargs)\nReturns the faces of a simplicial object, optionally restricted by dimension.\nIf s has an existing method s.faces(p), then that method is called with additional keyword arguments kwargs.\nOtherwise, the behavior of this function depends on the type-class of s. Namely, - if s is SimplexLike, then a generator enumerating p-combinations of s is returned. - if s is ComplexLike, then a generator enumerating p-faces of s (in any order) is returned. - if s is FiltrationLike, then a generator enumerating p-faces of s in filtration order is returned. - if s is none of the above but is Sized and Iterable, all combinations of s of length p+1 are chained and returned."
  },
  {
    "objectID": "reference/complexes.RankComplex.RankComplex.html",
    "href": "reference/complexes.RankComplex.RankComplex.html",
    "title": "complexes.RankComplex.RankComplex",
    "section": "",
    "text": "complexes.RankComplex.RankComplex(self, simplices=None)\nSimplicial complex represented via the combinatorial number system.\nA rank complex is a simplicial complex that stores simplices as integers (via their ranks) in contiguous memory. The integers are computed by bijecting each p-dimensional simplex to an integer in the range [0, comb(n,p+1))—this process is called ranking a simplex, and the correspondence between natural numbers and simplices is called the combinatorial numer system.\nComputationally, simplices are stored via ranks as 64-bit unsigned integers in an numpy array, and their vertex representations are computed on the fly by inverting the correspondence (‘unranking’) upon on access.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nsimplices\n\nstructured ndarray of dtype [(‘rank’, uint64), (‘dim’, uint8)] containing the simplex ranks and dimensions, respectively.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd\nAdds a simplex and its faces to the complex, if they do not already exist.\n\n\ncard\n\n\n\ncofaces\n\n\n\ndim\nThe maximal dimension of any simplex in the complex.\n\n\ndiscard\nRemoves simplices from the complex, if they exist.\n\n\nfaces\nEnumerates the faces of the complex.\n\n\nremove\nRemoves simplices from the complex. They must exist.\n\n\n\n\n\ncomplexes.RankComplex.RankComplex.add(self, item)\nAdds a simplex and its faces to the complex, if they do not already exist.\nIf item is already in the complex, the underlying complex is not modified.\n\n\n\ncomplexes.RankComplex.RankComplex.card(self, p=None)\n\n\n\ncomplexes.RankComplex.RankComplex.cofaces(self, item)\n\n\n\ncomplexes.RankComplex.RankComplex.dim(self)\nThe maximal dimension of any simplex in the complex.\n\n\n\ncomplexes.RankComplex.RankComplex.discard(self, item)\nRemoves simplices from the complex, if they exist.\nIf none of the supplied simplices are in the complex, the simplices are not modified.\n\n\n\ncomplexes.RankComplex.RankComplex.faces(self, p=None, **kwargs)\nEnumerates the faces of the complex.\n\n\np :  int, optional (default=None)\n\noptional integer indicating which dimension of faces to enumerate. Default to None (enumerates all faces).\n\n\n\n\n**** :  Iterable[SimplexLike], \n\ngenerator which yields on evaluation yields the simplex\n\n\n\n\n\ncomplexes.RankComplex.RankComplex.remove(self, item)\nRemoves simplices from the complex. They must exist.\nIf any of the supplied simplices are not in the complex, raise a KeyError."
  },
  {
    "objectID": "reference/generics.card.html",
    "href": "reference/generics.card.html",
    "title": "generics.card",
    "section": "",
    "text": "generics.card\ngenerics.card(s, p=None, **kwargs)\nCounts the number of p-dimensional simplices of a simplicial object s.\nIf s has an existing method s.card(p), then that method is called with additional keyword arguments kwargs.\nOtherwise, the behavior of this function depends on the type-class of s and whether p is specified. Namely, - If s is complex like, then card(s) returns a tuple containing the number of simplices in s in each dimension, and card(s, p) the number of simplices in s with dimension p."
  },
  {
    "objectID": "reference/UnionFind.UnionFind.html",
    "href": "reference/UnionFind.UnionFind.html",
    "title": "UnionFind.UnionFind",
    "section": "",
    "text": "UnionFind.UnionFind\nUnionFind.UnionFind(n)\nUnion Find data structure"
  },
  {
    "objectID": "reference/complexes.SimplexTree.html",
    "href": "reference/complexes.SimplexTree.html",
    "title": "complexes.SimplexTree",
    "section": "",
    "text": "complexes.SimplexTree\ncomplexes.SimplexTree"
  },
  {
    "objectID": "reference/filtrations.SetFiltration.SetFiltration.html",
    "href": "reference/filtrations.SetFiltration.SetFiltration.html",
    "title": "filtrations.SetFiltration.SetFiltration",
    "section": "",
    "text": "filtrations.SetFiltration.SetFiltration(self, simplices=None, f=None, order='lex')\nFiltered complex of simplices uses SortedSet.\nThis class represents a filtration of simplices by associating keys of a given index set with _SortedSet_s of Simplex instances. This class also implements the Mapping[Any, SimplexConvertible] Implements: getitem, iter, len, contains, keys, items, values, get, eq, and ne\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd\n\n\n\ncofaces\n\n\n\ncopy\n\n\n\ndim\n\n\n\nfaces\n\n\n\nindex\n\n\n\nindices\n\n\n\nreindex\nGiven a totally ordered key set of the same length of the filtation, or a callable, reindexes the simplices in the filtration\n\n\nupdate\n\n\n\n\n\n\nfiltrations.SetFiltration.SetFiltration.add(self, simplex)\n\n\n\nfiltrations.SetFiltration.SetFiltration.cofaces(self, item)\n\n\n\nfiltrations.SetFiltration.SetFiltration.copy(self)\n\n\n\nfiltrations.SetFiltration.SetFiltration.dim(self)\n\n\n\nfiltrations.SetFiltration.SetFiltration.faces(self, p=None, **kwargs)\n\n\n\nfiltrations.SetFiltration.SetFiltration.index(self, item)\n\n\n\nfiltrations.SetFiltration.SetFiltration.indices(self)\n\n\n\nfiltrations.SetFiltration.SetFiltration.reindex(self, index_set)\nGiven a totally ordered key set of the same length of the filtation, or a callable, reindexes the simplices in the filtration\n\n\n\nfiltrations.SetFiltration.SetFiltration.update(self, simplices)"
  }
]