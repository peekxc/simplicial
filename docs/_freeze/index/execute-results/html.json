{
  "hash": "4f042bf41bf0f85636157ee07542a4bb",
  "result": {
    "markdown": "---\nformat:\n  html:\n    code-fold: false\nexecute:\n  freeze: auto\n  enabled: true\ndraft: true\n---\n\n[![Tests](https://github.com/peekxc/splex/actions/workflows/package.yml/badge.svg)](https://github.com/peekxc/splex/actions/workflows/package.yml)\n[![coverage_badge](https://img.shields.io/endpoint?url=https://gist.githubusercontent.com/peekxc/ef42349965f40edf4232737026690c5f/raw/coverage_info.json)](https://coveralls.io/github/peekxc/splex)\n[![python_badge](https://img.shields.io/badge/python-3.9%20%7C%203.10%20%7C%203.11-blue)](https://github.com/peekxc/splex/actions/workflows/python-package.yml)\n[![coverage_badge](https://img.shields.io/github/actions/workflow/status/peekxc/splex/build-macos.yml?logo=apple&logoColor=white)](https://github.com/peekxc/splex/actions/workflows/build-macos.yml)\n[![coverage_badge](https://img.shields.io/github/actions/workflow/status/peekxc/splex/build-windows.yml?logo=windows&logoColor=white)](https://github.com/peekxc/splex/actions/workflows/build-windows.yml)\n[![coverage_badge](https://img.shields.io/github/actions/workflow/status/peekxc/splex/build-linux.yml?logo=linux&logoColor=white)](https://github.com/peekxc/splex/actions/workflows/build-linux.yml)\n\n`splex` is an experimental package for constructing, manipulating, and computing with simplicial complexes. \n\n## Quickstart \n\nWhat if there was a natural type for representing simplices? \n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nfrom splex import * \ns, t = Simplex([0,1,2]),  Simplex([0,1])\n\nprint(s.dim(), \":\", s)\n# 2 : (0,1,2)\n\nt < s, t <= s, s < t\n# True, True, False\n\nt in s.boundary()\n# True \n\nprint(list(s.faces()))\n# [(0), (1), (2), (0,1), (0,2), (1,2), (0,1,2)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2 : (0,1,2)\n[(0), (1), (2), (0,1), (0,2), (1,2), (0,1,2)]\n```\n:::\n:::\n\n\nWhat if said type was flexible and easy to work with, supporting no-fuss construction\n\n```python\nSimplex(2) == Simplex([2])                      # value-types are always unboxed \nSimplex([1,2]) == Simplex([1, 2, 2])            # simplices have unique entries, are hashable \nSimplex((1,5,3)) == Simplex(np.array([5,3,1]))  # arrays and tuples supported out of the box \nSimplex((0,1,2)) == Simplex(range(3))           # ... as are generators, iterables, collections, etc\n```\n\nWhat if it was easy to use with other native Python tools?\n```python\ns = Simplex([0,1,3,4])\nnp.array(s)          # native __array__ conversion enabled\nlen(s)               # __len__ is as expected \n3 in 3               # __contains__ acts vertex-wise\nlist(iter(s))        # __iter__ also acts vertex-wise\ns[0]                 # __getitem__ as well \ns[0] = 5             # __setitem__ is *not*: Simplices are immutable!\n\n# Which means native support for the expected protocols \nisinstance(s, Sized)     # True \nisinstance(s, Container) # True \nisinstance(s, Iterable)  # True \nisinstance(s, Mapping)   # False \n```\n\nWhat if there was a similar construction for simplicial complexes?\n```python\nS = simplicial_complex([[0,1,2,3], [4,5], [6]])\nprint(S)\n# 3-d complex with (7, 7, 4, 1)-simplices of dimension (0, 1, 2, 3)\n\n[s for s in S.faces()] # [(0), (1), ..., (1,2,3), (0,1,2,3)]\nS.add([5,6]) # adds Simplex([5,6]) to the complex \n```\n\n.. and for filtered complexes as well?\n```python\nK = filtration(S)\nprint(K)\n# 3-d filtered complex with (7, 7, 4, 1)-simplices of dimension (0, 1, 2, 3)\nprint(format(K))\n# 3-d filtered complex with (7, 7, 4, 1)-simplices of dimension (0, 1, 2, 3)\n# I: 0   ≤ 1   ≤ 2   ≤ 3   ≤ 4   ≤  ...  ≤ 17      ≤ 18       \n# S: (0) ⊆ (1) ⊆ (2) ⊆ (3) ⊆ (4) ⊆  ...  ⊆ (1,2,3) ⊆ (0,1,2,3)\n\n[s for s in K.faces()] # [(0), (1), ..., (1,2,3), (0,1,2,3)]\n```\n\nWhat if there were multiple choices in representation...\n\n\n```python\nSS = simplicial_complex([[0,1,2,3]], form=\"set\")  # simplices stored as sets: simple and extensible\nST = simplicial_complex([[0,1,2,3]], form=\"tree\") # simplex trees are compact and efficient to modify\nSR = simplicial_complex([[0,1,2,3]], form=\"rank\") # simplices stored in arrays integers: cache efficient to read\n# ... \n```\n\n...but every representation was supported through _generics_\n\n\n```python\nfaces(SS)           # calls overloaded .faces()\nfaces(ST)           # same as above, but using a simplex tree\nfaces(SR)           # same as above, but using a rank complex \nfaces([[0,1,2,3]]) # Equivalent! Falls back to combinations! \n# same goes for .card(), .dim(), .boundary(), ...\n```\n\nWhat if extending support to all such types generically was as easy as\n\n```python\ndef faces(S: ComplexLike) -> Iterator[SimplexConvertible]:\n  if hasattr(S, \"faces\"):\n    yield from S.faces()\n  else:\n    ...\n```\n\n...where `ComplexLike` is a protocol defining a minimal interface needed for Python types to be interpreted as complexes. \nThis is duck typing---no direct inheritance needed! Just define your type, make it _pythonic_ via abc.collections and go. \n\n\n```python\ndef MyCellComplex(ComplexLike):\n  def __iter__(self) -> Iterator[SimplexConvertible]:\n    ...\n```\n\n<!-- Of course, if the types could be *narrowed* for highly performant, type-specific algorithms?\n\n-->\n\n<!-- These are the goals of the `splex` package. Clean, extensible, performant.   -->\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}