[
  {
    "objectID": "overview.html",
    "href": "overview.html",
    "title": "Splex",
    "section": "",
    "text": "A simplicial complex S = (V, \\Sigma) is a collection of simplices s \\in \\Sigma satisfying:\n\nEach v \\in V is in S\nIf \\tau \\subset \\sigma and \\sigma \\in S, then \\tau \\in S\n\n\n\n\n\n\n\nTip\n\n\n\nThough highly related, this package is structured for representing abstract simplicial complexes, the purely combinatorial analog to the topological space obtained by ‘gluing’ together simplices.\n\n\n \\Delta = \\{\\sigma \\}\n\n\nkjbakdaok"
  },
  {
    "objectID": "design.html",
    "href": "design.html",
    "title": "Splex",
    "section": "",
    "text": "Suppose you wanted to represent a combinatorial n-simplex. Why not use a built-in sequence type?\nsimplex = [0,1,2] # why note use a list? \nBut wait, simplices are simple value objects, just like strings ('abc') or integers (123), which are immutable and hashable. Perhaps a tuple then?\nsimplex = (0,1,2)\nBut wait, simplices are set-like: they have unique entries and are comparable. But (0,1,1,1,1,2) is clearly not a simplex, though it is immutable. How about a set?\nsimplex = set([0,1,2])\nSets actually are naturally comparable and have unique entries:\nface = set([1,2])\nface <= simplex # True\nset([2,1,0,1]) == simplex # True \nBut ahhh, they are also mutable! How about frozenset?\nsimplex = frozenset([0,1,2])\nImmutable, comparable, unique… this seems fine. Except it’s elements are not homogenous\nsimplex = frozenset([0,1,'a',2,'b'])\nThere’s no technical reason not use non-type-homogenous vertex sets—however, mixing types may imply different per-element memory layouts, and comparability between elements becomes muddled.\nIndeed, it seems the Python data model doesn’t have an immutable, homogenous, set-like container.\n\nlists are mutable, non-homogenous, and non-hashable\ntuples are comparable and immutable, but they are not set like\nfrozensets are comparable, immutable, and set-like, but are neither homogenous nor ordered\nSortedSet comes close, but is neither immutable nor hashable.\narray & np.array are homogenous but not immutable and not set like\nbytes lack only set like functionality—however their values are limited to [0, 255]\n\nThere seems to be no built-in Python sequence appropriate for a simplex. So, why not make our own!\n\n\nclass Simplex(Hashable):\n  pass\nAs an aside, Python affectuionados may point to the fact that most of the above process of designing a class can be heavily side-stepped using various decorators patterns, like Python’s dataclasses. For example, here’s a very similar class to the one above.\n@dataclass(frozen=True)\nclass Simplex(Collection[int]):\n  vertices = field(default_factory=SortedSet, compare=True) \n\n\n\nNow that we have a ‘nice’ representation of a Simplex, let’s build a simplicial complex.\n\n\n\nAnd now onto the elephant in the room: let’s see how performant our types are.\n\ns = Simplex([0,1,2])\n\nNow suppose, we replace this with a simple numpy-based solution.\n\nAfter all this effort, our class design of a simplex is at best complex and at worst monolithic. Although it seems elegant and natural to use, its simply not a very practical from a performance perspective. Indeed, if we’re going to be operating on 1e8+ simplices at a time, it’s far more efficient to simply stream operations with a [numpy] array!\nOf course, with the numpy solution, it seems we lose all the structure we built into the classes. Searching takes… This is a seemingly fundamental tradeoff. Why can’t we have the best of both worlds?\nAn entirely different structure, such as a numpy array, may be more performant in some settings… but in others, perhaps a memory efficient solution using the combinatorial number system makes sense.\n\n\n\nThis is a common pattern that exists in other languages. In Haskell, they’re called typeclasses. In Rust, they’re traits. In Swift, they’re called protocols. In D, a related thing is called type constraints. These appear over and over in other languages. Swift celebrates itself as a protocol-oriented language. https://www.youtube.com/watch?v=E-2y1qHQvTg\nWadler, Philip, and Stephen Blott. “How to make ad-hoc polymorphism less ad hoc.” Proceedings of the 16th ACM SIGPLAN-SIGACT symposium on Principles of programming languages. 1989.\nWith all of these types, its clear there are going to be memory and time complexity tradeoffs associated with each type. Searcing might take longer in one, but shorter in the other… One representation might be extremely compact and great for read-only streaming…. another might be more suitable for a time-varying setting, where the underlying complex is constantly changing via simplex insertions, deletions, and reorderings.\nIt would be nice to have a interface to unify all of these sturctures, such that primitive operations on them are carried out in a DRY-manner. Ideally, the interface should be minimal—requiring only what is strictly necessary—but also performant, taking advantage of structure wherever it exists. Moreover, the interface should ideally be easily extensible, type flexible, and open source fruendly."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Splex",
    "section": "",
    "text": "Simplicial is an experimental Python package aimed at simplifying computation with simplicial complexes.\n\n\n\n\nimport simplicial"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "simplextree_ds.html",
    "href": "simplextree_ds.html",
    "title": "Splex",
    "section": "",
    "text": "Simplex Tree\nThe simplex tree is…\n\n\n\nsimplextree"
  },
  {
    "objectID": "reference/SetLike.html",
    "href": "reference/SetLike.html",
    "title": "Splex",
    "section": "",
    "text": "meta.SetLike()\nProtocol for annotating set-like types."
  },
  {
    "objectID": "reference/Sequence.html",
    "href": "reference/Sequence.html",
    "title": "Splex",
    "section": "",
    "text": "meta.Sequence()"
  },
  {
    "objectID": "reference/ComplexLike.html",
    "href": "reference/ComplexLike.html",
    "title": "Splex",
    "section": "",
    "text": "meta.ComplexLike()\nProtocol interface for types that represent (abstract) simplicial complexes\nAn type ComplexLike if it is a iterable collection of SimplexLike objects, and it the following methods: - dim : None -> int - faces : int -> Iterable[SimplexLike]\nProtocols: Collection[Sized, Iterable, Container] Methods: contains, iter, len\n\n\n\n\nComplexLike.dim(self)\n\n\n\n\nComplexLike.faces(self, p: int)"
  },
  {
    "objectID": "reference/SimplexTree.html",
    "href": "reference/SimplexTree.html",
    "title": "Splex",
    "section": "",
    "text": "simplextree.SimplexTree(self, simplices: Iterable[SimplexLike] = None)\nSimplexTree provides lightweight wrapper around a Simplex Tree data structure: an ordered, trie-like structure whose nodes are in bijection with the faces of the complex. This class exposes a native extension module wrapping a simplex tree implemented with modern C++.\nThe Simplex Tree was originally introduced in the paper > Boissonnat, Jean-Daniel, and Clément Maria. “The simplex tree: An efficient data structure for general simplicial complexes.” Algorithmica 70.3 (2014): 406-427.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nn_simplices\nndarray\nnumber of simplices\n\n\ndimension\nint\nmaximal dimension of the complex\n\n\nid_policy\nstr\npolicy for generating new vertex ids\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nvertices\nndarray\nvertices of the complex\n\n\n\n\n\n\n\n\nSimplexTree.insert(self, simplices: Iterable[SimplexLike])\nInserts simplices into the Simplex Tree.\nBy definition, inserting a simplex also inserts all of its faces. If the simplex already exists in the complex, the tree is not modified.\n\n\nsimplices :  Iterable[SimplexLike], required\n\nIterable of simplices to insert (each of which are SimplexLike)\n\n\n\n\n\n\n\nNote\n\n\n\n    If the iterable is an 2-dim np.ndarray, then a p-simplex is inserted along each contiguous p+1 stride.\n    Otherwise, each element of the iterable to casted to a Simplex and then inserted into the tree. \n\n\n\n\n\n\n\nSimplexTree.remove(self, simplices: Iterable[SimplexLike])\nRemoves simplices into the Simplex Tree.\nBy definition, removing a face also removes all of its cofaces. If the simplex does not exist in the complex, the tree is not modified.\n\n\nsimplices :  Iterable[SimplexLike], required\n\nIterable of simplices to insert (each of which are SimplexLike).\n\n\n\n\n\n\n\nNote\n\n\n\n    If the iterable is an 2-dim np.ndarray, then a p-simplex is removed along each contiguous p+1 stride.\n    Otherwise, each element of the iterable to casted to a Simplex and then removed from the tree. \n\n\n\n\n\n\n\nSimplexTree.find(self, simplices: Iterable[SimplexLike])\nFinds whether simplices exist in Simplex Tree.\n\n\nsimplices :  Iterable[SimplexLike], required\n\nIterable of simplices to insert (each of which are SimplexLike)\n\n\n\n\n**** :\n\nfound (ndarray) : boolean array for each simplex indicating whether it was found in the complex\n\n\n\n\n\n\n\nNote\n\n\n\n    If the iterable is an 2-dim np.ndarray, then the p-simplex to find is given by each contiguous p+1 stride.\n    Otherwise, each element of the iterable to casted to a Simplex and then searched for in the tree. \n\n\n\n\n\n\n\nSimplexTree.adjacent(self, simplices: Iterable)\nChecks for adjacencies between simplices\n\n\n\n\nSimplexTree.collapse(self, tau: SimplexLike, sigma: SimplexLike)\nChecks whether its possible to collapse \\sigma through \\tau, and if so, both simplices are removed. A simplex \\sigma is said to be collapsible through one of its faces \\tau if \\sigma is the only coface of \\tau (excluding \\tau itself).\n\n\nsigma : required\n\nmaximal simplex to collapse\n\ntau : required\n\nface of sigma to collapse\n\n\n\n\nbool : None,\n\nwhether the pair was collapsed\n\n\n\n\n\nfrom splex import SimplexTree \nst = SimplexTree([[0,1,2]])\nprint(st)\n\nst.collapse([1,2], [0,1,2])\n\nprint(st)\n\nSimplex Tree with (3, 3, 1) (0, 1, 2)-simplices\nSimplex Tree with (3, 2) (0, 1)-simplices\n\n\n\n\n\n\n\nSimplexTree.vertex_collapse(self, u: int, v: int, w: int)\nMaps a pair of vertices into a single vertex.\n\n\nu :  int, required\n\nthe first vertex in the free pair.\n\nv :  int, required\n\nthe second vertex in the free pair.\n\nw :  int, required\n\nthe target vertex to collapse to.\n\n\n\n\n\n\nSimplexTree.degree(self, vertices: Optional[ArrayLike] = None)\nComputes the degree of select vertices in the trie.\n\n\nvertices :  numpy.typing.ArrayLike, optional (default=None)\n\nRetrieves vertex degrees If no vertices are specified, all degrees are computed. Non-existing vertices by default have degree 0.\n\n\n\n\nlist :  Union[ArrayLike, int], \n\ndegree of each vertex id given in ‘vertices’\n\n\n\n\n\n\nSimplexTree.traverse(order: str = 'preorder', f: Callable = print, sigma: SimplexLike = [], p: int = 0)\nTraverses the simplex tree in the specified order, calling ‘f’ on each simplex encountered\nSupported traversals: - breadth-first (“bfs”)\n\n\norder : optional (default=‘preorder’)\n\nthe type of traversal to do\n\nf : optional (default=print)\n\na function to evaluate on every simplex in the traversal. Defaults to print.\n\nsigma : optional (default=[])\n\nsimplex to start the traversal at, where applicable. Defaults to the root node (empty set)\n\np : optional (default=0)\n\ndimension of simplices to restrict to, where applicable.\n\n\n\n\n\n\nSimplexTree.cofaces(self, p: int = None, sigma: SimplexLike = [])\nFinds the p-dimensional cofaces of sigma.\n\n\np : optional (default=None)\n\ncoface dimension to restrict to\n\nsigma : optional (default=[])\n\nthe simplex to obtain cofaces of\n\n\n\n\nlist :  list[SimplexLike], \n\nthe p-cofaces of sigma\n\n\n\n\n\n\nSimplexTree.coface_roots(self, p: int = None, sigma: SimplexLike = [])\n\n\n\n\nSimplexTree.skeleton(self, p: int = None)\n\n\n\n\nSimplexTree.simplices(self, p: int = None, sigma: SimplexLike = [])\n\n\n\n\nSimplexTree.maximal(self)\n\n\n\n\nSimplexTree.link(self, sigma: SimplexLike = [])\n\n\n\n\nSimplexTree.expand(self, k: int)\nPerforms a k-expansion of the complex.\nThis function is particularly useful for expanding clique complexes beyond their 1-skeleton.\n\n\nk : required\n\nmaximum dimension to expand to.\n\n\n\n\n\nfrom splex import SimplexTree \nfrom itertools import combinations \nst = SimplexTree(combinations(range(8), 2))\nprint(st)\n\nst.expand(k=2)\nprint(st)\n\nSimplex Tree with (8, 28) (0, 1)-simplices\nSimplex Tree with (8, 28, 56) (0, 1, 2)-simplices"
  },
  {
    "objectID": "reference/MutableFiltration.html",
    "href": "reference/MutableFiltration.html",
    "title": "Splex",
    "section": "",
    "text": "splex.MutableFiltration(self, simplices: Union[SimplicialComplex, Iterable] = None, f: Optional[Callable] = None)\nSimplicial Filtration\nImplements: getitem, iter, len, contains, keys, items, values, get, eq, and ne\n\n\n\n\nMutableFiltration.update(self, other: Iterable[Tuple[Any, Collection[Integral]]])\n\n\n\n\nMutableFiltration.setdefault(self, key, default)\n\n\n\n\nMutableFiltration.copy(self)\n\n\n\n\nMutableFiltration.keys(self)\n\n\n\n\nMutableFiltration.values(self)\n\n\n\n\nMutableFiltration.items(self)\n\n\n\n\nMutableFiltration.reindex_keys(self, index_set: Iterable)\nGiven a totally ordered key set of the same length of the filtation, reindexes\n\n\n\n\nMutableFiltration.faces(self, p: int = None)\n\n\n\n\nMutableFiltration.print(self, kwargs)\n\n\n\n\nMutableFiltration.validate(self, light: bool = True)"
  },
  {
    "objectID": "reference/SimplicialComplex.html",
    "href": "reference/SimplicialComplex.html",
    "title": "Splex",
    "section": "",
    "text": "splex.SimplicialComplex(self, simplices: Iterable[SimplexLike] = None)\nAbstract Simplicial Complex\n\n\n\n\nSimplicialComplex.dim(self)\n\n\n\n\nSimplicialComplex.faces(self, p: Optional[int] = None)\n\n\n\n\nSimplicialComplex.update(self, simplices: Iterable[SimplexLike])\n\n\n\n\nSimplicialComplex.add(self, item: Collection[int])\n\n\n\n\nSimplicialComplex.remove(self, item: Collection[int])\n\n\n\n\nSimplicialComplex.discard(self, item: Collection[int])\n\n\n\n\nSimplicialComplex.cofaces(self, item: Collection[int])\n\n\n\n\nSimplicialComplex.print(self, kwargs)"
  },
  {
    "objectID": "reference/combinatorial.html",
    "href": "reference/combinatorial.html",
    "title": "Splex",
    "section": "",
    "text": "combinatorial.rank_C2(i: int, j: int, n: int)"
  },
  {
    "objectID": "reference/combinatorial.html#combinatorial.unrank_C2",
    "href": "reference/combinatorial.html#combinatorial.unrank_C2",
    "title": "Splex",
    "section": "combinatorial.unrank_C2",
    "text": "combinatorial.unrank_C2\ncombinatorial.unrank_C2(x: int, n: int)"
  },
  {
    "objectID": "reference/combinatorial.html#combinatorial.unrank_lex",
    "href": "reference/combinatorial.html#combinatorial.unrank_lex",
    "title": "Splex",
    "section": "combinatorial.unrank_lex",
    "text": "combinatorial.unrank_lex\ncombinatorial.unrank_lex(r: int, k: int, n: int)"
  },
  {
    "objectID": "reference/combinatorial.html#combinatorial.rank_lex",
    "href": "reference/combinatorial.html#combinatorial.rank_lex",
    "title": "Splex",
    "section": "combinatorial.rank_lex",
    "text": "combinatorial.rank_lex\ncombinatorial.rank_lex(c: Iterable, n: int)"
  },
  {
    "objectID": "reference/combinatorial.html#combinatorial.rank_colex",
    "href": "reference/combinatorial.html#combinatorial.rank_colex",
    "title": "Splex",
    "section": "combinatorial.rank_colex",
    "text": "combinatorial.rank_colex\ncombinatorial.rank_colex(c: Iterable)"
  },
  {
    "objectID": "reference/combinatorial.html#combinatorial.unrank_colex",
    "href": "reference/combinatorial.html#combinatorial.unrank_colex",
    "title": "Splex",
    "section": "combinatorial.unrank_colex",
    "text": "combinatorial.unrank_colex\ncombinatorial.unrank_colex(r: int, k: int)\nUnranks a k-combinations rank ‘r’ back into the original combination in colex order\nFrom: Unranking Small Combinations of a Large Set in Co-Lexicographic Order"
  },
  {
    "objectID": "reference/combinatorial.html#combinatorial.rank_combs",
    "href": "reference/combinatorial.html#combinatorial.rank_combs",
    "title": "Splex",
    "section": "combinatorial.rank_combs",
    "text": "combinatorial.rank_combs\ncombinatorial.rank_combs(C: Iterable[tuple], n: int = None, order: str = ['colex', 'lex'])\nRanks k-combinations to integer ranks in either lexicographic or colexicographical order\nParameters: C : Iterable of combinations n : cardinality of the set (lex order only) order : the bijection to use\nReturns: list : unsigned integers ranks in the chosen order."
  },
  {
    "objectID": "reference/combinatorial.html#combinatorial.unrank_combs",
    "href": "reference/combinatorial.html#combinatorial.unrank_combs",
    "title": "Splex",
    "section": "combinatorial.unrank_combs",
    "text": "combinatorial.unrank_combs\ncombinatorial.unrank_combs(R: Iterable[int], k: Union[int, Iterable], n: int = None, order: str = ['colex', 'lex'])\nUnranks integer ranks to k-combinations in either lexicographic or colexicographical order\nParameters: R : Iterable of integer ranks n : cardinality of the set (lex order only) order : the bijection to use\nReturns: list : k-combinations derived from R"
  },
  {
    "objectID": "reference/FiltrationLike.html",
    "href": "reference/FiltrationLike.html",
    "title": "Splex",
    "section": "",
    "text": "meta.FiltrationLike()\nAn object is FiltrationLike if it is ComplexLike and is a Sequence of SimplexLike objects.\n\n\n\n\nFiltrationLike.index(self, other: SimplexLike)"
  },
  {
    "objectID": "reference/CombinatorialComplex.html",
    "href": "reference/CombinatorialComplex.html",
    "title": "Splex",
    "section": "",
    "text": "filtration.CombinatorialComplex(self, simplices: Union[SimplicialComplex, Iterable] = None)\nSimplicial Complex represented via the combinatorial number system\n\n\n\n\nCombinatorialComplex.dim(self)\n\n\n\n\nCombinatorialComplex.faces(self, p: int = None)"
  },
  {
    "objectID": "reference/generics.html",
    "href": "reference/generics.html",
    "title": "Splex",
    "section": "",
    "text": "generics.dim(sigma: Union[SimplexLike, ComplexLike])\nReturns the dimension of a simplicial object, suitably defined"
  },
  {
    "objectID": "reference/generics.html#generics.boundary",
    "href": "reference/generics.html#generics.boundary",
    "title": "Splex",
    "section": "generics.boundary",
    "text": "generics.boundary\ngenerics.boundary(s: Union[SimplexLike, ComplexLike])\nReturns the boundary of a simplicial object, suitably defined"
  },
  {
    "objectID": "reference/generics.html#generics.faces",
    "href": "reference/generics.html#generics.faces",
    "title": "Splex",
    "section": "generics.faces",
    "text": "generics.faces\ngenerics.faces(s: Union[SimplexLike, ComplexLike])\nReturns the boundary of a simplicial object, suitably defined"
  },
  {
    "objectID": "reference/constructions.html",
    "href": "reference/constructions.html",
    "title": "Splex",
    "section": "",
    "text": "constructions.rips_filtration(X: ArrayLike, radius: float)"
  },
  {
    "objectID": "reference/Simplex.html",
    "href": "reference/Simplex.html",
    "title": "Splex",
    "section": "",
    "text": "splex.Simplex(self, v: Collection[Integral])\nImplements: contains(self, v: int) <=> Returns whether integer ‘v’ is a vertex in ‘self’\n\n\n\n\nSimplex.faces(self, p: Optional[int] = None)\n\n\n\n\nSimplex.boundary(self)\n\n\n\n\nSimplex.dim(self)"
  },
  {
    "objectID": "reference/Comparable.html",
    "href": "reference/Comparable.html",
    "title": "Splex",
    "section": "",
    "text": "meta.Comparable()\nProtocol for annotating comparable types."
  },
  {
    "objectID": "reference/MutableSequence.html",
    "href": "reference/MutableSequence.html",
    "title": "Splex",
    "section": "",
    "text": "meta.MutableSequence()"
  },
  {
    "objectID": "reference/SimplexLike.html",
    "href": "reference/SimplexLike.html",
    "title": "Splex",
    "section": "",
    "text": "meta.SimplexLike()\nAn object is SimplexLike if it is Immutable, Hashable, and SetLike\nBy definition, this implies a simplex is sized, iterable, and acts as a container (supports vertex contains queries)\nProtocols: SetLike[Container, Comparable], Hashable, Immutable Abstract Methods: hash, contains, len, iter, setitem"
  },
  {
    "objectID": "reference/CombinatorialFiltration.html",
    "href": "reference/CombinatorialFiltration.html",
    "title": "Splex",
    "section": "",
    "text": "filtration.CombinatorialFiltration(self, simplices: Union[SimplicialComplex, Iterable], f: Callable = None)\n\n\n\n\nCombinatorialFiltration.reindex(self, f: Callable[SimplexLike, Any])"
  }
]