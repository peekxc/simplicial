[
  {
    "objectID": "overview.html",
    "href": "overview.html",
    "title": "Simplicial",
    "section": "",
    "text": "A simplicial complex S = (V, \\Sigma) is a collection of simplices s \\in \\Sigma satisfying:\n\nEach v \\in V is in S\nIf \\tau \\subset \\sigma and \\sigma \\in S, then \\tau \\in S\n\n\n\n\n\n\n\nTip\n\n\n\nThough highly related, this package is structured for representing abstract simplicial complexes, the purely combinatorial analog to the topological space obtained by ‘gluing’ together simplices.\n\n\n \\Delta = \\{\\sigma \\}\n\n\nkjbakdaok"
  },
  {
    "objectID": "design.html",
    "href": "design.html",
    "title": "Simplicial",
    "section": "",
    "text": "Suppose you wanted to represent a combinatorial n-simplex. Why not use a built-in sequence type?\nsimplex = [0,1,2] # why note use a list? \nBut wait, simplices are simple value objects, just like strings ('abc') or integers (123), which are immutable and hashable. Perhaps a tuple then?\nsimplex = (0,1,2)\nBut wait, simplices are set-like: they have unique entries and are comparable. But (0,1,1,1,1,2) is clearly not a simplex, though it is immutable. How about a set?\nsimplex = set([0,1,2])\nSets actually are naturally comparable and have unique entries:\nface = set([1,2])\nface <= simplex # True\nset([2,1,0,1]) == simplex # True \nBut ahhh, they are also mutable! How about frozenset?\nsimplex = frozenset([0,1,2])\nImmutable, comparable, unique… this seems fine. Except it’s elements are not homogenous\nsimplex = frozenset([0,1,'a',2,'b'])\nThere’s no technical reason not use non-type-homogenous vertex sets—however, mixing types may imply different per-element memory layouts, and comparability between elements becomes muddled.\nIndeed, it seems the Python data model doesn’t have an immutable, homogenous, set-like container.\n\nlists are mutable, non-homogenous, and non-hashable\ntuples are comparable and immutable, but they are not set like\nfrozensets are comparable, immutable, and set-like, but are neither homogenous nor ordered\nSortedSet comes close, but is neither immutable nor hashable.\narray & np.array are homogenous but not immutable and not set like\nbytes lack only set like functionality—however their values are limited to [0, 255]\n\nThere seems to be no built-in Python sequence appropriate for a simplex. So, why not make our own!\n\n\nclass Simplex(Hashable):\n  pass\nAs an aside, Python affectuionados may point to the fact that most of the above process of designing a class can be heavily side-stepped using various decorators patterns, like Python’s dataclasses. For example, here’s a very similar class to the one above.\n@dataclass(frozen=True)\nclass Simplex(Collection[int]):\n  vertices = field(default_factory=SortedSet, compare=True) \n\n\n\nNow that we have a ‘nice’ representation of a Simplex, let’s build a simplicial complex.\n\n\n\nAnd now onto the elephant in the room: let’s see how performant our types are.\n\ns = Simplex([0,1,2])\n\nNow suppose, we replace this with a simple numpy-based solution.\n\nAfter all this effort, our class design of a simplex is at best complex and at worst monolithic. Although it seems elegant and natural to use, its simply not a very practical from a performance perspective. Indeed, if we’re going to be operating on 1e8+ simplices at a time, it’s far more efficient to simply stream operations with a [numpy] array!\nOf course, with the numpy solution, it seems we lose all the structure we built into the classes. Searching takes… This is a seemingly fundamental tradeoff. Why can’t we have the best of both worlds?\nAn entirely different structure, such as a numpy array, may be more performant in some settings… but in others, perhaps a memory efficient solution using the combinatorial number system makes sense.\n\n\n\nWith all of these types, its clear there are going to be memory and time complexity tradeoffs associated with each type. Searcing might take longer in one, but shorter in the other… One representation might be extremely compact and great for read-only streaming…. another might be more suitable for a time-varying setting, where the underlying complex is constantly changing via simplex insertions, deletions, and reorderings.\nIt would be nice to have a interface to unify all of these sturctures, such that primitive operations on them are carried out in a DRY-manner. Ideally, the interface should be minimal—requiring only what is strictly necessary—but also performant, taking advantage of structure wherever it exists. Moreover, the interface should ideally be easily extensible, type flexible, and open source fruendly."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Simplicial",
    "section": "",
    "text": "Simplicial is an experimental Python package aimed at simplifying computation with simplicial complexes.\n\n\n\n\nimport simplicial"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "simplextree_ds.html",
    "href": "simplextree_ds.html",
    "title": "Simplicial",
    "section": "",
    "text": "Simplex Tree\nThe simplex tree is…\n\n\n\nsimplextree"
  },
  {
    "objectID": "test.html",
    "href": "test.html",
    "title": "Simplicial",
    "section": "",
    "text": ".. autoclass:: simplicial.simplicial.Simplex .. autoclass:: simplicial.simplicial.SimplicialComplex .. autoclass:: simplicial.simplicial.MutableFiltration"
  }
]